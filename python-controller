#!/usr/bin/env python3
"""
Socket Hook Monitor with Packet Capture

This program loads the socket_hook.o eBPF program and attaches it to a network
interface to capture and analyze packet flows. It displays per-flow statistics
including packet counts, byte counts, and protocol information.

Usage:
    sudo python3 python-controller --interface eth0 --interval 5

Requirements:
    - BCC (BPF Compiler Collection) Python bindings
    - Root privileges (sudo)
    - Compiled socket_hook.o eBPF program
"""

from bcc import BPF
import argparse
import signal
import sys
import time
import socket
import struct
import os

# Global flag for graceful shutdown on Ctrl+C
# This allows the signal handler to communicate with the main loop
keep_running = True

# Global socket reference for cleanup
# We need this to properly close the socket in the finally block
raw_socket = None


def signal_handler(sig, frame):
    """
    Handle interrupt signals (Ctrl+C) for graceful shutdown.
    
    When the user presses Ctrl+C, this function sets the keep_running flag
    to False, which causes the main monitoring loop to exit cleanly.
    
    Args:
        sig: Signal number (e.g., SIGINT = 2)
        frame: Current stack frame (not used)
    """
    global keep_running
    print("\n\nReceived interrupt signal. Shutting down gracefully...")
    keep_running = False


def format_ip(ip_int):
    """
    Convert a 32-bit integer IP address to dotted decimal notation.
    
    IP addresses in the BPF maps are stored as 32-bit integers in network
    byte order. This function converts them to human-readable format.
    
    Args:
        ip_int: 32-bit integer representing an IPv4 address
        
    Returns:
        String in format "192.168.1.1"
        
    Example:
        format_ip(0x0100007f) -> "127.0.0.1"
    """
    # Pack as 32-bit integer, then unpack as 4 bytes for inet_ntoa
    # 'I' format means unsigned int (32 bits)
    return socket.inet_ntoa(struct.pack("I", ip_int))


def format_port(port_int):
    """
    Convert port number from network byte order to host byte order.
    
    Ports in BPF maps are stored in network byte order (big-endian).
    This function converts them to the host's native byte order for display.
    
    Args:
        port_int: Port number in network byte order (16-bit)
        
    Returns:
        Port number in host byte order (0-65535)
        
    Example:
        format_port(0x5000) -> 80 (assuming big-endian network order)
    """
    return socket.ntohs(port_int)


def print_stats(bpf_prog):
    """
    Display statistics from the socket_metrics BPF map.
    
    This function reads all flow entries from the BPF hash map and displays
    them in a human-readable format. Flows are sorted by packet count with
    the most active flows shown first.
    
    Args:
        bpf_prog: BPF program object containing the socket_metrics map
        
    Note:
        Only displays the top 10 most active flows to keep output manageable.
    """
    # Access the socket_metrics map from the loaded BPF program
    # BCC provides dict-like access to BPF maps
    socket_metrics = bpf_prog["socket_metrics"]
    
    # Print header section
    print("\n" + "=" * 70)
    print(" Socket Hook Statistics")
    print("=" * 70)
    
    # Check if any flows have been captured yet
    if len(socket_metrics) == 0:
        print("\nNo flows captured yet.")
        print("Generate network traffic with: ping 8.8.8.8 or curl https://example.com")
        print()
        return
    
    # Convert BPF map items to list for sorting
    # Each item is a tuple: (flow_key, packet_metrics)
    flows = [(k, v) for k, v in socket_metrics.items()]
    
    # Sort flows by packet count in descending order (most active first)
    # x[1] is the metrics struct, packets_processed is its first field
    flows.sort(key=lambda x: x[1].packets_processed, reverse=True)
    
    # Display summary information
    print(f"\nTotal active flows: {len(flows)}")
    print(f"Showing top {min(len(flows), 10)} flows by packet count:\n")
    
    # Mapping of IP protocol numbers to readable names
    # See: /etc/protocols or RFC 5237
    protocol_names = {
        1: "ICMP",    # Internet Control Message Protocol
        6: "TCP",     # Transmission Control Protocol
        17: "UDP",    # User Datagram Protocol
        41: "IPv6",   # IPv6 encapsulation
        47: "GRE",    # Generic Routing Encapsulation
        50: "ESP",    # Encapsulating Security Payload
    }
    
    # Display the top 10 most active flows
    for i, (key, metrics) in enumerate(flows[:10], 1):
        # Get human-readable protocol name, or show number if unknown
        proto = protocol_names.get(key.proto, f"Proto-{key.proto}")
        
        # Format and display flow information
        # Format: src_ip:src_port → dst_ip:dst_port (protocol)
        print(f"Flow #{i}:")
        print(f"  {format_ip(key.src_ip)}:{format_port(key.src_port)} → "
              f"{format_ip(key.dst_ip)}:{format_port(key.dst_port)} ({proto})")
        
        # Display packet and byte statistics with thousand separators
        print(f"  Packets: {metrics.packets_processed:,}")
        print(f"  Bytes:   {metrics.bytes_processed:,}")
        
        # Calculate and display average packet size
        # Use max() to avoid division by zero
        avg_size = metrics.bytes_processed // max(metrics.packets_processed, 1)
        print(f"  Average packet size: {avg_size} bytes")
        print()  # Blank line between flows
    
    # Show indicator if there are more flows not displayed
    if len(flows) > 10:
        print(f"... and {len(flows) - 10} more flows not shown\n")


def validate_interface(interface_name):
    """
    Check if a network interface exists on the system.
    
    Args:
        interface_name: Name of the network interface (e.g., "eth0", "wlan0")
        
    Returns:
        True if interface exists, False otherwise
    """
    try:
        # Try to get the interface index; raises OSError if not found
        socket.if_nametoindex(interface_name)
        return True
    except OSError:
        return False


def list_interfaces():
    """
    Get a list of all available network interfaces on the system.
    
    Returns:
        List of interface names as strings
    """
    interfaces = []
    # Read from /sys/class/net which contains all network interfaces
    net_dir = "/sys/class/net"
    if os.path.exists(net_dir):
        interfaces = os.listdir(net_dir)
    return interfaces


def main():
    """
    Main program entry point.
    
    This function:
    1. Parses command-line arguments
    2. Validates prerequisites (root, interface exists, BPF file exists)
    3. Loads the eBPF program and attaches it to a network interface
    4. Monitors and displays packet statistics until interrupted
    5. Cleans up resources on exit
    """
    global keep_running, raw_socket
    
    # Configure command-line argument parser
    parser = argparse.ArgumentParser(
        description="Socket Hook Monitor - Load and monitor eBPF socket filter",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Monitor eth0 interface, update every 5 seconds
  sudo python3 python-controller --interface eth0 --interval 5
  
  # Monitor with custom BPF program location
  sudo python3 python-controller --bpf-file custom/socket_hook.o
  
  # Quick monitoring with 2-second updates
  sudo python3 python-controller -i 2

Notes:
  - Must be run as root (use sudo)
  - Interface must exist and be up
  - BPF program must be compiled first (run 'make')
        """
    )
    
    parser.add_argument(
        "--bpf-file",
        default=".output/socket_hook.o",
        help="Path to compiled eBPF object file (default: .output/socket_hook.o)"
    )
    
    parser.add_argument(
        "-i", "--interval",
        type=int,
        default=5,
        help="Statistics display interval in seconds (default: 5)"
    )
    
    parser.add_argument(
        "--interface",
        default="eth0",
        help="Network interface to monitor (default: eth0)"
    )
    
    # Parse command-line arguments
    args = parser.parse_args()
    
    # ========================================================================
    # Pre-flight checks: Verify prerequisites before attempting to load BPF
    # ========================================================================
    
    # Check 1: Root privileges required
    if os.geteuid() != 0:
        print("ERROR: This program must be run as root")
        print("       eBPF programs require root privileges to load into the kernel")
        print("\nUsage: sudo python3 python-controller")
        sys.exit(1)
    
    # Check 2: BPF object file exists
    if not os.path.exists(args.bpf_file):
        print(f"ERROR: BPF object file not found: {args.bpf_file}")
        print("\nDid you compile the eBPF program?")
        print("Run: make")
        sys.exit(1)
    
    # Check 3: Network interface exists
    if not validate_interface(args.interface):
        print(f"ERROR: Network interface '{args.interface}' not found")
        print("\nAvailable interfaces:")
        for iface in list_interfaces():
            print(f"  - {iface}")
        print("\nSpecify a valid interface with: --interface <name>")
        sys.exit(1)
    
    # Check 4: Validate interval is positive
    if args.interval <= 0:
        print("ERROR: Interval must be a positive number")
        sys.exit(1)
    
    # Display startup banner
    print("=" * 70)
    print(" Socket Hook Monitor - eBPF Packet Capture")
    print("=" * 70)
    print(f"\nConfiguration:")
    print(f"  BPF Program:  {args.bpf_file}")
    print(f"  Interface:    {args.interface}")
    print(f"  Update Interval: {args.interval} seconds")
    print()
    
    # Set up signal handler for graceful Ctrl+C handling
    # This must be done before loading the BPF program
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    try:
        # ====================================================================
        # Load and attach eBPF program
        # ====================================================================
        
        print("Loading eBPF program...")
        
        # Load the compiled BPF object file
        # BCC reads the .o file and loads all programs and maps
        b = BPF(src_file=args.bpf_file)
        print("  ✓ BPF object loaded")
        
        # Find and load the socket filter function
        # This must match the SEC("socket_filter") function name in socket_hook.c
        fn = b.load_func("socket_packet_filter", BPF.SOCKET_FILTER)
        print("  ✓ Socket filter function found")
        
        # Create a raw packet socket
        # AF_PACKET: Low-level packet interface
        # SOCK_RAW: Raw packets including link-level header
        # 0x0003: ETH_P_ALL in network byte order (capture all protocols)
        raw_socket = socket.socket(
            socket.AF_PACKET,    # Address family: packet interface
            socket.SOCK_RAW,     # Socket type: raw packets
            socket.htons(0x0003) # Protocol: ETH_P_ALL (all protocols)
        )
        print("  ✓ Raw packet socket created")
        
        # Attach the BPF program to the socket
        # SO_ATTACH_BPF: Socket option to attach a BPF filter
        # fn.fd: File descriptor of the loaded BPF program
        raw_socket.setsockopt(
            socket.SOL_SOCKET,      # Socket level option
            socket.SO_ATTACH_BPF,   # Attach BPF filter
            fn.fd                   # BPF program file descriptor
        )
        print("  ✓ BPF filter attached to socket")
        
        # Bind socket to the specific network interface
        # This ensures we only capture packets from the specified interface
        raw_socket.bind((args.interface, 0))
        print(f"  ✓ Socket bound to interface {args.interface}")
        
        print("\n" + "=" * 70)
        print("Packet capture is now active!")
        print("Press Ctrl+C to stop and exit")
        print("=" * 70)
        
        # ====================================================================
        # Main monitoring loop
        # ====================================================================
        
        # Continuously display statistics until interrupted
        while keep_running:
            # Sleep for the specified interval
            time.sleep(args.interval)
            
            # Display current statistics from BPF maps
            print_stats(b)
        
    except PermissionError:
        # Shouldn't reach here due to earlier root check, but just in case
        print("\nERROR: Permission denied")
        print("Make sure you're running with sudo")
        sys.exit(1)
        
    except OSError as e:
        # Handle socket-related errors (interface issues, etc.)
        print(f"\nERROR: {e}")
        print(f"Failed to work with interface '{args.interface}'")
        print("\nTroubleshooting:")
        print("  1. Verify interface exists: ip link show")
        print("  2. Verify interface is up: sudo ip link set {args.interface} up")
        sys.exit(1)
        
    except KeyError as e:
        # Handle missing BPF map/function errors
        print(f"\nERROR: Could not find BPF object: {e}")
        print("Make sure socket_hook.o was compiled correctly")
        print("Expected BPF objects:")
        print("  - Function: socket_packet_filter")
        print("  - Map: socket_metrics")
        sys.exit(1)
        
    except Exception as e:
        # Catch-all for unexpected errors
        print(f"\nERROR: Unexpected error occurred")
        print(f"Details: {e}")
        print("\nStack trace:")
        import traceback
        traceback.print_exc()
        sys.exit(1)
        
    finally:
        # ====================================================================
        # Cleanup: Always executed, even on error or interrupt
        # ====================================================================
        
        print("\n" + "=" * 70)
        print("Cleaning up resources...")
        
        # Close the raw socket if it was created
        if raw_socket is not None:
            try:
                raw_socket.close()
                print("  ✓ Socket closed")
            except Exception as e:
                print(f"  ⚠ Warning: Failed to close socket: {e}")
        
        # BCC automatically cleans up BPF programs when the object is destroyed
        print("  ✓ BPF program detached")
        print("\nShutdown complete. Goodbye!")
        print("=" * 70)


# Standard Python idiom: only run main() if this script is executed directly
# (not if it's imported as a module)
if __name__ == "__main__":
    main()