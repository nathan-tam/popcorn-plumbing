#!/usr/bin/env python3
"""
Socket Hook Monitor

Loads a pre-compiled eBPF socket filter using libbpf and displays packet statistics.

Usage:
    sudo python3 python-controller --interface lo

Requirements:
    - libbpf: sudo apt-get install libbpf-dev
    - Root privileges (sudo)
    - Compiled eBPF program: make
"""

import argparse
import ctypes
import ctypes.util
import os
import signal
import socket
import struct
import sys
import time


# ============================================================================
# Constants
# ============================================================================

SO_ATTACH_BPF = 50       # Socket option to attach eBPF program
ETH_P_ALL = 0x0003       # Capture all Ethernet protocols
BPF_MAP_LOOKUP_ELEM = 1  # BPF syscall command: lookup map element
BPF_MAP_GET_NEXT_KEY = 4 # BPF syscall command: iterate map keys
__NR_bpf = 321           # BPF syscall number on x86_64 Linux


# ============================================================================
# Data Structures
#
# These must exactly match the C structs in common.h, including padding.
# ============================================================================

class FlowKey(ctypes.Structure):
    """
    5-tuple flow identifier.
    
    Matches struct flow_key in common.h (16 bytes total).
    Used as the key in the BPF hash map.
    """
    _fields_ = [
        ("src_ip", ctypes.c_uint32),     # Source IP (network byte order)
        ("dst_ip", ctypes.c_uint32),     # Destination IP (network byte order)
        ("src_port", ctypes.c_uint16),   # Source port (network byte order)
        ("dst_port", ctypes.c_uint16),   # Destination port (network byte order)
        ("proto", ctypes.c_uint8),       # Protocol (1=ICMP, 6=TCP, 17=UDP)
        ("_pad", ctypes.c_uint8 * 3),    # Padding for alignment
    ]


class PacketMetrics(ctypes.Structure):
    """
    Per-flow packet statistics.
    
    Matches struct packet_metrics in common.h (32 bytes total).
    Used as the value in the BPF hash map.
    """
    _fields_ = [
        ("packets_processed", ctypes.c_uint32),  # Packet count
        ("_pad", ctypes.c_uint32),               # Padding (C compiler inserts this)
        ("bytes_processed", ctypes.c_uint64),    # Total bytes
        ("total_latency_ns", ctypes.c_uint64),   # Reserved for latency tracking
        ("timestamp", ctypes.c_uint64),          # Last seen (nanoseconds)
    ]


# ============================================================================
# libbpf Wrapper
#
# Provides Python access to libbpf functions for loading eBPF programs.
# ============================================================================

class LibBPF:
    """
    Minimal wrapper around the libbpf shared library.
    
    Uses ctypes to call libbpf functions for:
    - Opening compiled eBPF object files (.o)
    - Loading programs into the kernel
    - Getting file descriptors for programs and maps
    """
    
    def __init__(self):
        """Find and load the libbpf shared library."""
        # Try standard library lookup first
        lib_path = ctypes.util.find_library("bpf")
        
        # Fall back to common installation paths
        if not lib_path:
            for path in ["/usr/lib/x86_64-linux-gnu/libbpf.so.1",
                         "/usr/lib/x86_64-linux-gnu/libbpf.so.0",
                         "/usr/lib/libbpf.so.1",
                         "/usr/lib/libbpf.so"]:
                if os.path.exists(path):
                    lib_path = path
                    break
        
        if not lib_path:
            raise OSError("libbpf not found. Install: sudo apt-get install libbpf-dev")
        
        self.lib = ctypes.CDLL(lib_path, use_errno=True)
        self._setup_function_signatures()
    
    def _setup_function_signatures(self):
        """Define C function argument/return types for type safety."""
        L = self.lib
        
        # Opening and loading BPF objects
        L.bpf_object__open.argtypes = [ctypes.c_char_p]
        L.bpf_object__open.restype = ctypes.c_void_p
        
        L.bpf_object__load.argtypes = [ctypes.c_void_p]
        L.bpf_object__load.restype = ctypes.c_int
        
        L.bpf_object__close.argtypes = [ctypes.c_void_p]
        L.bpf_object__close.restype = None
        
        # Finding programs by name
        L.bpf_object__find_program_by_name.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        L.bpf_object__find_program_by_name.restype = ctypes.c_void_p
        
        L.bpf_program__fd.argtypes = [ctypes.c_void_p]
        L.bpf_program__fd.restype = ctypes.c_int
        
        # Finding maps by name
        L.bpf_object__find_map_by_name.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        L.bpf_object__find_map_by_name.restype = ctypes.c_void_p
        
        L.bpf_map__fd.argtypes = [ctypes.c_void_p]
        L.bpf_map__fd.restype = ctypes.c_int
    
    def open_and_load(self, path):
        """
        Open a compiled BPF object file and load it into the kernel.
        
        Returns the BPF object handle (needed for cleanup).
        """
        obj = self.lib.bpf_object__open(path.encode())
        if not obj:
            raise OSError(f"Failed to open: {path}")
        
        if self.lib.bpf_object__load(obj) != 0:
            self.lib.bpf_object__close(obj)
            raise OSError(f"Failed to load: {path}")
        
        return obj
    
    def close(self, obj):
        """Close a BPF object and free resources."""
        if obj:
            self.lib.bpf_object__close(obj)
    
    def get_program_fd(self, obj, name):
        """Get the file descriptor for a BPF program by name."""
        prog = self.lib.bpf_object__find_program_by_name(obj, name.encode())
        if not prog:
            raise ValueError(f"Program not found: {name}")
        
        fd = self.lib.bpf_program__fd(prog)
        if fd < 0:
            raise ValueError(f"Invalid program fd: {name}")
        return fd
    
    def get_map_fd(self, obj, name):
        """Get the file descriptor for a BPF map by name."""
        m = self.lib.bpf_object__find_map_by_name(obj, name.encode())
        if not m:
            raise ValueError(f"Map not found: {name}")
        
        fd = self.lib.bpf_map__fd(m)
        if fd < 0:
            raise ValueError(f"Invalid map fd: {name}")
        return fd


# ============================================================================
# BPF Map Operations
#
# Uses the bpf() syscall directly to read entries from BPF maps.
# ============================================================================

# Cache libc to avoid reloading on each syscall
_libc = ctypes.CDLL(None, use_errno=True)


class _BpfMapAttr(ctypes.Structure):
    """
    Attribute structure for BPF map syscalls.
    
    This matches the kernel's bpf_attr union for map operations.
    See: linux/bpf.h
    """
    _fields_ = [
        ("map_fd", ctypes.c_uint32),    # File descriptor of the map
        ("_pad", ctypes.c_uint32),      # Padding for alignment
        ("key_ptr", ctypes.c_uint64),   # Pointer to key buffer
        ("val_ptr", ctypes.c_uint64),   # Pointer to value/next_key buffer
    ]


def _bpf_map_syscall(cmd, map_fd, key_ptr, val_ptr):
    """
    Execute a BPF map syscall.
    
    Args:
        cmd: BPF_MAP_LOOKUP_ELEM or BPF_MAP_GET_NEXT_KEY
        map_fd: Map file descriptor
        key_ptr: Address of key buffer (or 0 for first key)
        val_ptr: Address of value buffer (lookup) or next_key buffer (iterate)
    
    Returns:
        True on success, False on error (e.g., key not found, no more keys)
    """
    attr = _BpfMapAttr(
        map_fd=map_fd,
        key_ptr=key_ptr,
        val_ptr=val_ptr
    )
    ret = _libc.syscall(__NR_bpf, cmd, ctypes.byref(attr), ctypes.sizeof(attr))
    return ret >= 0


def iterate_map(map_fd):
    """
    Read all entries from a BPF hash map.
    
    Uses BPF_MAP_GET_NEXT_KEY to iterate through keys,
    and BPF_MAP_LOOKUP_ELEM to get the value for each key.
    
    Returns:
        List of (FlowKey, PacketMetrics) tuples
    """
    entries = []
    
    # Working buffers (reused during iteration)
    key = FlowKey()
    next_key = FlowKey()
    value = PacketMetrics()
    
    # Get the first key by passing NULL (0) as the current key
    if not _bpf_map_syscall(BPF_MAP_GET_NEXT_KEY, map_fd, 0, ctypes.addressof(next_key)):
        return entries  # Map is empty
    
    while True:
        # Move next_key to key for the lookup
        ctypes.pointer(key)[0] = next_key
        
        # Look up the value for this key
        if _bpf_map_syscall(BPF_MAP_LOOKUP_ELEM, map_fd,
                           ctypes.addressof(key), ctypes.addressof(value)):
            # Create copies to store (the buffers get overwritten)
            entries.append((
                FlowKey.from_buffer_copy(bytes(key)),
                PacketMetrics.from_buffer_copy(bytes(value))
            ))
        
        # Get the next key (using current key as reference)
        if not _bpf_map_syscall(BPF_MAP_GET_NEXT_KEY, map_fd,
                               ctypes.addressof(key), ctypes.addressof(next_key)):
            break  # No more keys
    
    return entries


# ============================================================================
# Display Helpers
# ============================================================================

def format_ip(ip_int):
    """Convert 32-bit integer to dotted decimal (e.g., "127.0.0.1")."""
    # IP is in network byte order, pack as-is
    return socket.inet_ntoa(struct.pack("I", ip_int))


def format_port(port_int):
    """Convert port from network byte order to host byte order."""
    return socket.ntohs(port_int)


def get_interfaces():
    """Get list of available network interfaces."""
    try:
        return sorted(os.listdir("/sys/class/net"))
    except OSError:
        return []


# ============================================================================
# Main Program
# ============================================================================

# Global flag for clean shutdown
keep_running = True


def signal_handler(sig, frame):
    """Handle Ctrl+C for graceful shutdown."""
    global keep_running
    print("\n\nStopping...")
    keep_running = False


def main():
    global keep_running
    
    # -------------------------------------------------------------------------
    # Parse command-line arguments
    # -------------------------------------------------------------------------
    parser = argparse.ArgumentParser(description="eBPF Socket Hook Monitor")
    parser.add_argument("--bpf-file", default=".output/socket_hook.o",
                        help="Path to compiled eBPF object")
    parser.add_argument("--interface", default="lo",
                        help="Network interface to monitor")
    parser.add_argument("-i", "--interval", type=int, default=5,
                        help="Update interval in seconds")
    args = parser.parse_args()
    
    # -------------------------------------------------------------------------
    # Validate prerequisites
    # -------------------------------------------------------------------------
    if os.geteuid() != 0:
        sys.exit("ERROR: Run as root (sudo)")
    
    if not os.path.exists(args.bpf_file):
        sys.exit(f"ERROR: {args.bpf_file} not found. Run 'make' first.")
    
    interfaces = get_interfaces()
    if args.interface not in interfaces:
        sys.exit(f"ERROR: Interface '{args.interface}' not found. "
                 f"Available: {', '.join(interfaces)}")
    
    # -------------------------------------------------------------------------
    # Display configuration
    # -------------------------------------------------------------------------
    print("=" * 60)
    print("Socket Hook Monitor")
    print("=" * 60)
    print(f"BPF File:  {args.bpf_file}")
    print(f"Interface: {args.interface}")
    print(f"Interval:  {args.interval}s")
    print()
    
    # Set up signal handlers for clean shutdown
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # -------------------------------------------------------------------------
    # Load BPF program and attach to socket
    # -------------------------------------------------------------------------
    
    # Initialize to None for cleanup in finally block
    bpf_obj = None
    sock = None
    libbpf = None
    
    try:
        # Load the compiled eBPF program
        print("Loading eBPF program...")
        libbpf = LibBPF()
        bpf_obj = libbpf.open_and_load(args.bpf_file)
        print("  ✓ Loaded into kernel")
        
        # Get file descriptors for the program and map
        prog_fd = libbpf.get_program_fd(bpf_obj, "socket_packet_filter")
        map_fd = libbpf.get_map_fd(bpf_obj, "socket_metrics")
        print(f"  ✓ Program fd={prog_fd}, Map fd={map_fd}")
        
        # Create a raw packet socket
        # AF_PACKET: Layer 2 access
        # SOCK_RAW: Include headers
        # ETH_P_ALL: All protocols
        sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))
        
        # Attach the BPF filter to the socket
        sock.setsockopt(socket.SOL_SOCKET, SO_ATTACH_BPF, struct.pack("I", prog_fd))
        
        # Bind to the specified interface
        sock.bind((args.interface, 0))
        print(f"  ✓ Attached to {args.interface}")
        
        # ---------------------------------------------------------------------
        # Monitoring loop
        # ---------------------------------------------------------------------
        print("\n" + "=" * 60)
        print("Monitoring... Press Ctrl+C to stop")
        print("=" * 60)
        
        proto_names = {1: "ICMP", 6: "TCP", 17: "UDP"}
        
        while keep_running:
            time.sleep(args.interval)
            if not keep_running:
                break
            
            # Read all flows from the BPF map
            flows = iterate_map(map_fd)
            
            # Display flow statistics
            print("\n" + "-" * 60)
            print(f"Active flows: {len(flows)}")
            print("-" * 60)
            
            if not flows:
                print("No traffic captured yet. Try: ping 127.0.0.1")
                continue
            
            # Sort by packet count (highest first)
            flows.sort(key=lambda x: x[1].packets_processed, reverse=True)
            
            # Show top 10 flows
            for i, (key, val) in enumerate(flows[:10], 1):
                proto = proto_names.get(key.proto, f"Proto-{key.proto}")
                src = f"{format_ip(key.src_ip)}:{format_port(key.src_port)}"
                dst = f"{format_ip(key.dst_ip)}:{format_port(key.dst_port)}"
                print(f"{i:2}. {src} → {dst} ({proto})")
                print(f"    Packets: {val.packets_processed:,}  "
                      f"Bytes: {val.bytes_processed:,}")
    
    except (OSError, ValueError) as e:
        sys.exit(f"\nERROR: {e}")
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        sys.exit(f"\nERROR: {e}")
    
    finally:
        # Clean up resources
        if sock:
            sock.close()
        if bpf_obj and libbpf:
            libbpf.close(bpf_obj)
    
    print("\n" + "=" * 60)
    print("Goodbye!")
    print("=" * 60)


if __name__ == "__main__":
    main()