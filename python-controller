#!/usr/bin/env python3
"""
eBPF Hook Monitor

Loads pre-compiled eBPF programs using libbpf and displays packet statistics.
Supports both socket-layer and TC (Traffic Control) hooks.

Usage:
    sudo python3 python-controller --interface lo

Requirements:
    - libbpf: sudo apt-get install libbpf-dev
    - Root privileges (sudo)
    - Compiled eBPF programs: make
"""

import argparse
import ctypes
import ctypes.util
import os
import signal
import socket
import struct
import subprocess
import sys
import time


# ============================================================================
# Constants
# ============================================================================

SO_ATTACH_BPF = 50       # Socket option to attach eBPF program
ETH_P_ALL = 0x0003       # Capture all Ethernet protocols
BPF_MAP_LOOKUP_ELEM = 1  # BPF syscall command: lookup map element
BPF_MAP_GET_NEXT_KEY = 4 # BPF syscall command: iterate map keys
__NR_bpf = 321           # BPF syscall number on x86_64 Linux

# Hook types
HOOK_SOCKET = "socket"
HOOK_TC = "tc"


# ============================================================================
# Data Structures
#
# These must exactly match the C structs in common.h, including padding.
# ============================================================================

class FlowKey(ctypes.Structure):
    """
    5-tuple flow identifier.
    
    Matches struct flow_key in common.h (16 bytes total).
    Used as the key in the BPF hash map.
    """
    _fields_ = [
        ("src_ip", ctypes.c_uint32),     # Source IP (network byte order)
        ("dst_ip", ctypes.c_uint32),     # Destination IP (network byte order)
        ("src_port", ctypes.c_uint16),   # Source port (network byte order)
        ("dst_port", ctypes.c_uint16),   # Destination port (network byte order)
        ("proto", ctypes.c_uint8),       # Protocol (1=ICMP, 6=TCP, 17=UDP)
        ("_pad", ctypes.c_uint8 * 3),    # Padding for alignment
    ]


class PacketMetrics(ctypes.Structure):
    """
    Per-flow packet statistics.
    
    Matches struct packet_metrics in common.h (32 bytes total).
    Used as the value in the BPF hash map.
    """
    _fields_ = [
        ("packets_processed", ctypes.c_uint32),  # Packet count
        ("_pad", ctypes.c_uint32),               # Padding (C compiler inserts this)
        ("bytes_processed", ctypes.c_uint64),    # Total bytes
        ("total_latency_ns", ctypes.c_uint64),   # Reserved for latency tracking
        ("timestamp", ctypes.c_uint64),          # Last seen (nanoseconds)
    ]


# ============================================================================
# libbpf Wrapper
#
# Provides Python access to libbpf functions for loading eBPF programs.
# ============================================================================

class LibBPF:
    """
    Minimal wrapper around the libbpf shared library.
    
    Uses ctypes to call libbpf functions for:
    - Opening compiled eBPF object files (.o)
    - Loading programs into the kernel
    - Getting file descriptors for programs and maps
    """
    
    def __init__(self):
        """Find and load the libbpf shared library."""
        # Try standard library lookup first
        lib_path = ctypes.util.find_library("bpf")
        
        # Fall back to common installation paths
        if not lib_path:
            for path in ["/usr/lib/x86_64-linux-gnu/libbpf.so.1",
                         "/usr/lib/x86_64-linux-gnu/libbpf.so.0",
                         "/usr/lib/libbpf.so.1",
                         "/usr/lib/libbpf.so"]:
                if os.path.exists(path):
                    lib_path = path
                    break
        
        if not lib_path:
            raise OSError("libbpf not found. Install: sudo apt-get install libbpf-dev")
        
        self.lib = ctypes.CDLL(lib_path, use_errno=True)
        self._setup_function_signatures()
    
    def _setup_function_signatures(self):
        """Define C function argument/return types for type safety."""
        L = self.lib
        
        # Opening and loading BPF objects
        L.bpf_object__open.argtypes = [ctypes.c_char_p]
        L.bpf_object__open.restype = ctypes.c_void_p
        
        L.bpf_object__load.argtypes = [ctypes.c_void_p]
        L.bpf_object__load.restype = ctypes.c_int
        
        L.bpf_object__close.argtypes = [ctypes.c_void_p]
        L.bpf_object__close.restype = None
        
        # Finding programs by name
        L.bpf_object__find_program_by_name.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        L.bpf_object__find_program_by_name.restype = ctypes.c_void_p
        
        L.bpf_program__fd.argtypes = [ctypes.c_void_p]
        L.bpf_program__fd.restype = ctypes.c_int
        
        # Finding maps by name
        L.bpf_object__find_map_by_name.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        L.bpf_object__find_map_by_name.restype = ctypes.c_void_p
        
        L.bpf_map__fd.argtypes = [ctypes.c_void_p]
        L.bpf_map__fd.restype = ctypes.c_int
    
    def open_and_load(self, path):
        """
        Open a compiled BPF object file and load it into the kernel.
        
        Returns the BPF object handle (needed for cleanup).
        """
        obj = self.lib.bpf_object__open(path.encode())
        if not obj:
            raise OSError(f"Failed to open: {path}")
        
        if self.lib.bpf_object__load(obj) != 0:
            self.lib.bpf_object__close(obj)
            raise OSError(f"Failed to load: {path}")
        
        return obj
    
    def close(self, obj):
        """Close a BPF object and free resources."""
        if obj:
            self.lib.bpf_object__close(obj)
    
    def get_program_fd(self, obj, name):
        """Get the file descriptor for a BPF program by name."""
        prog = self.lib.bpf_object__find_program_by_name(obj, name.encode())
        if not prog:
            raise ValueError(f"Program not found: {name}")
        
        fd = self.lib.bpf_program__fd(prog)
        if fd < 0:
            raise ValueError(f"Invalid program fd: {name}")
        return fd
    
    def get_map_fd(self, obj, name):
        """Get the file descriptor for a BPF map by name."""
        m = self.lib.bpf_object__find_map_by_name(obj, name.encode())
        if not m:
            raise ValueError(f"Map not found: {name}")
        
        fd = self.lib.bpf_map__fd(m)
        if fd < 0:
            raise ValueError(f"Invalid map fd: {name}")
        return fd


# ============================================================================
# BPF Map Operations
#
# Uses the bpf() syscall directly to read entries from BPF maps.
# ============================================================================

# Cache libc to avoid reloading on each syscall
_libc = ctypes.CDLL(None, use_errno=True)


class _BpfMapAttr(ctypes.Structure):
    """
    Attribute structure for BPF map syscalls.
    
    This matches the kernel's bpf_attr union for map operations.
    See: linux/bpf.h
    """
    _fields_ = [
        ("map_fd", ctypes.c_uint32),    # File descriptor of the map
        ("_pad", ctypes.c_uint32),      # Padding for alignment
        ("key_ptr", ctypes.c_uint64),   # Pointer to key buffer
        ("val_ptr", ctypes.c_uint64),   # Pointer to value/next_key buffer
    ]


def _bpf_map_syscall(cmd, map_fd, key_ptr, val_ptr):
    """
    Execute a BPF map syscall.
    
    Args:
        cmd: BPF_MAP_LOOKUP_ELEM or BPF_MAP_GET_NEXT_KEY
        map_fd: Map file descriptor
        key_ptr: Address of key buffer (or 0 for first key)
        val_ptr: Address of value buffer (lookup) or next_key buffer (iterate)
    
    Returns:
        True on success, False on error (e.g., key not found, no more keys)
    """
    attr = _BpfMapAttr(
        map_fd=map_fd,
        key_ptr=key_ptr,
        val_ptr=val_ptr
    )
    ret = _libc.syscall(__NR_bpf, cmd, ctypes.byref(attr), ctypes.sizeof(attr))
    return ret >= 0


def iterate_map(map_fd):
    """
    Read all entries from a BPF hash map.
    
    Uses BPF_MAP_GET_NEXT_KEY to iterate through keys,
    and BPF_MAP_LOOKUP_ELEM to get the value for each key.
    
    Returns:
        List of (FlowKey, PacketMetrics) tuples
    """
    entries = []
    
    # Working buffers (reused during iteration)
    key = FlowKey()
    next_key = FlowKey()
    value = PacketMetrics()
    
    # Get the first key by passing NULL (0) as the current key
    if not _bpf_map_syscall(BPF_MAP_GET_NEXT_KEY, map_fd, 0, ctypes.addressof(next_key)):
        return entries  # Map is empty
    
    while True:
        # Move next_key to key for the lookup
        ctypes.pointer(key)[0] = next_key
        
        # Look up the value for this key
        if _bpf_map_syscall(BPF_MAP_LOOKUP_ELEM, map_fd,
                           ctypes.addressof(key), ctypes.addressof(value)):
            # Create copies to store (the buffers get overwritten)
            entries.append((
                FlowKey.from_buffer_copy(bytes(key)),
                PacketMetrics.from_buffer_copy(bytes(value))
            ))
        
        # Get the next key (using current key as reference)
        if not _bpf_map_syscall(BPF_MAP_GET_NEXT_KEY, map_fd,
                               ctypes.addressof(key), ctypes.addressof(next_key)):
            break  # No more keys
    
    return entries


# ============================================================================
# TC Hook Management
#
# Uses the 'tc' command to attach/detach TC eBPF programs.
# ============================================================================

class TCHook:
    """
    Manages TC (Traffic Control) hook attachment/detachment.
    
    TC hooks are attached using the 'tc' command-line tool, which sets up
    the qdisc (queueing discipline) and filters for eBPF program attachment.
    """
    
    def __init__(self, interface, bpf_file):
        self.interface = interface
        self.bpf_file = bpf_file
        self.attached = False
    
    def _run_tc(self, args, check=True):
        """Run a tc command and return success status."""
        cmd = ["tc"] + args
        try:
            result = subprocess.run(cmd, capture_output=True, text=True)
            if check and result.returncode != 0:
                # Ignore "file exists" errors when adding qdisc (already exists)
                if "File exists" not in result.stderr:
                    return False, result.stderr.strip()
            return True, result.stdout.strip()
        except FileNotFoundError:
            return False, "tc command not found. Install: sudo apt-get install iproute2"
    
    def attach(self):
        """
        Attach TC eBPF program to the interface.
        
        Steps:
        1. Add clsact qdisc (allows both ingress and egress hooks)
        2. Attach ingress filter with our eBPF program
        """
        # Step 1: Add clsact qdisc (may already exist, that's OK)
        success, err = self._run_tc(
            ["qdisc", "add", "dev", self.interface, "clsact"],
            check=False  # Ignore "file exists" error
        )
        
        # Step 2: Attach ingress filter
        success, err = self._run_tc([
            "filter", "add", "dev", self.interface,
            "ingress", "bpf", "direct-action",
            "obj", self.bpf_file, "sec", "tc"
        ])
        if not success:
            raise OSError(f"Failed to attach TC ingress filter: {err}")
        
        # Step 3: Attach egress filter (catches outgoing traffic)
        success, err = self._run_tc([
            "filter", "add", "dev", self.interface,
            "egress", "bpf", "direct-action",
            "obj", self.bpf_file, "sec", "tc"
        ])
        if not success:
            raise OSError(f"Failed to attach TC egress filter: {err}")
        

        self.attached = True
    
    def detach(self):
        """
        Detach TC eBPF program from the interface.
        
        Removes the clsact qdisc, which also removes all attached filters.
        """
        if not self.attached:
            return
        
        # Remove the clsact qdisc (this removes all filters too)
        self._run_tc(["qdisc", "del", "dev", self.interface, "clsact"], check=False)
        self.attached = False


# ============================================================================
# Display Helpers
# ============================================================================

def format_ip(ip_int):
    """Convert 32-bit integer to dotted decimal (e.g., "127.0.0.1")."""
    # IP is in network byte order, pack as-is
    return socket.inet_ntoa(struct.pack("I", ip_int))


def format_port(port_int):
    """Convert port from network byte order to host byte order."""
    return socket.ntohs(port_int)


def get_interfaces():
    """Get list of available network interfaces."""
    try:
        return sorted(os.listdir("/sys/class/net"))
    except OSError:
        return []


def select_hook_type():
    """
    Display menu and let user select which hook type to use.
    
    Returns:
        HOOK_SOCKET or HOOK_TC
    """
    print("=" * 60)
    print("eBPF Hook Monitor - Select Hook Type")
    print("=" * 60)
    print()
    print("Available hook types:")
    print()
    print("  1. Socket Layer Hook")
    print("     - Attaches to a raw packet socket")
    print("     - Sees packets after they reach the socket layer")
    print("     - Uses bpf_skb_load_bytes() for packet access")
    print()
    print("  2. TC (Traffic Control) Hook")
    print("     - Attaches at the qdisc/traffic control layer")
    print("     - Sees packets earlier in the network stack")
    print("     - Uses direct packet access (more efficient)")
    print()
    
    while True:
        try:
            choice = input("Select hook type [1-2]: ").strip()
            if choice == "1":
                return HOOK_SOCKET
            elif choice == "2":
                return HOOK_TC
            else:
                print("Invalid choice. Please enter 1 or 2.")
        except (EOFError, KeyboardInterrupt):
            print("\nAborted.")
            sys.exit(0)


# ============================================================================
# Main Program
# ============================================================================

# Global flag for clean shutdown
keep_running = True


def signal_handler(sig, frame):
    """Handle Ctrl+C for graceful shutdown."""
    global keep_running
    print("\n\nStopping...")
    keep_running = False


def main():
    global keep_running
    
    # -------------------------------------------------------------------------
    # Parse command-line arguments
    # -------------------------------------------------------------------------
    parser = argparse.ArgumentParser(
        description="eBPF Hook Monitor - Monitor network traffic using eBPF",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    sudo python3 python-controller --interface eth0
    sudo python3 python-controller --interface lo --interval 2
    sudo python3 python-controller --hook socket --interface eth0
    sudo python3 python-controller --hook tc --interface eth0
        """
    )
    parser.add_argument("--interface", default="lo",
                        help="Network interface to monitor (default: lo)")
    parser.add_argument("-i", "--interval", type=int, default=5,
                        help="Update interval in seconds (default: 5)")
    parser.add_argument("--hook", choices=["socket", "tc"],
                        help="Hook type: 'socket' or 'tc' (if not specified, will prompt)")
    args = parser.parse_args()
    
    # -------------------------------------------------------------------------
    # Validate prerequisites
    # -------------------------------------------------------------------------
    if os.geteuid() != 0:
        sys.exit("ERROR: Run as root (sudo)")
    
    interfaces = get_interfaces()
    if args.interface not in interfaces:
        sys.exit(f"ERROR: Interface '{args.interface}' not found. "
                 f"Available: {', '.join(interfaces)}")
    
    # -------------------------------------------------------------------------
    # Select hook type (prompt if not specified on command line)
    # -------------------------------------------------------------------------
    if args.hook:
        hook_type = args.hook
    else:
        hook_type = select_hook_type()
    
    # Determine BPF file and program/map names based on hook type
    if hook_type == HOOK_SOCKET:
        bpf_file = ".output/socket_hook.o"
        prog_name = "socket_packet_filter"
        map_name = "socket_metrics"
        hook_display = "Socket Layer"
    else:  # HOOK_TC
        bpf_file = ".output/tc_hook.o"
        prog_name = "tc_packet_filter"
        map_name = "tc_metrics"
        hook_display = "TC (Traffic Control)"
    
    # Verify BPF file exists
    if not os.path.exists(bpf_file):
        sys.exit(f"ERROR: {bpf_file} not found. Run 'make' first.")
    
    # -------------------------------------------------------------------------
    # Display configuration
    # -------------------------------------------------------------------------
    print()
    print("=" * 60)
    print(f"{hook_display} Hook Monitor")
    print("=" * 60)
    print(f"Hook Type: {hook_display}")
    print(f"BPF File:  {bpf_file}")
    print(f"Interface: {args.interface}")
    print(f"Interval:  {args.interval}s")
    print()
    
    # Set up signal handlers for clean shutdown
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # -------------------------------------------------------------------------
    # Load BPF program and attach
    # -------------------------------------------------------------------------
    
    # Initialize to None for cleanup in finally block
    bpf_obj = None
    sock = None
    tc_hook = None
    libbpf = None
    
    try:
        # Load the compiled eBPF program
        print("Loading eBPF program...")
        libbpf = LibBPF()
        bpf_obj = libbpf.open_and_load(bpf_file)
        print("  ✓ Loaded into kernel")
        
        # Get file descriptors for the program and map
        prog_fd = libbpf.get_program_fd(bpf_obj, prog_name)
        map_fd = libbpf.get_map_fd(bpf_obj, map_name)
        print(f"  ✓ Program fd={prog_fd}, Map fd={map_fd}")
        
        # For TC hook, also get the debug map
        debug_map_fd = None
        if hook_type == HOOK_TC:
            try:
                debug_map_fd = libbpf.get_map_fd(bpf_obj, "tc_debug")
                print(f"  ✓ Debug map fd={debug_map_fd}")
            except ValueError:
                print("  ⚠ Debug map not found (older tc_hook.o?)")
        
        
        # Attach based on hook type
        if hook_type == HOOK_SOCKET:
            # Create a raw packet socket and attach BPF filter
            sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))
            sock.setsockopt(socket.SOL_SOCKET, SO_ATTACH_BPF, struct.pack("I", prog_fd))
            sock.bind((args.interface, 0))
            print(f"  ✓ Attached to socket on {args.interface}")
        
        else:  # HOOK_TC
            # Use tc command to attach at the TC layer
            tc_hook = TCHook(args.interface, bpf_file)
            tc_hook.attach()
            print(f"  ✓ Attached TC hook on {args.interface}")
        
        # ---------------------------------------------------------------------
        # Monitoring loop
        # ---------------------------------------------------------------------
        print("\n" + "=" * 60)
        print("Monitoring... Press Ctrl+C to stop")
        print("=" * 60)
        
        proto_names = {1: "ICMP", 6: "TCP", 17: "UDP"}
        
        while keep_running:
            time.sleep(args.interval)
            if not keep_running:
                break
            
            # DEBUG: Read debug counters for TC hook
            if hook_type == HOOK_TC and debug_map_fd is not None:
                print("\n" + "=" * 60)
                print("DEBUG COUNTERS (from BPF program):")
                debug_names = ["Total packets", "IPv4 packets", "Parsed packets", "Map updates"]
                for i in range(4):
                    key = ctypes.c_uint32(i)
                    value = ctypes.c_uint64(0)
                    if _bpf_map_syscall(BPF_MAP_LOOKUP_ELEM, debug_map_fd,
                                       ctypes.addressof(key), ctypes.addressof(value)):
                        print(f"  {debug_names[i]}: {value.value}")
                    else:
                        print(f"  {debug_names[i]}: <read failed>")
                print("=" * 60)
            
            # Read all flows from the BPF map
            flows = iterate_map(map_fd)
            
            # Display flow statistics
            print("\n" + "-" * 60)
            print(f"[{hook_display}] Active flows: {len(flows)}")
            print("-" * 60)
            
            if not flows:
                print("No traffic captured yet. Try: ping 127.0.0.1")
                continue
            
            # Sort by packet count (highest first)
            flows.sort(key=lambda x: x[1].packets_processed, reverse=True)
            
            # Show top 10 flows
            for i, (key, val) in enumerate(flows[:10], 1):
                proto = proto_names.get(key.proto, f"Proto-{key.proto}")
                src = f"{format_ip(key.src_ip)}:{format_port(key.src_port)}"
                dst = f"{format_ip(key.dst_ip)}:{format_port(key.dst_port)}"
                print(f"{i:2}. {src} → {dst} ({proto})")
                print(f"    Packets: {val.packets_processed:,}  "
                      f"Bytes: {val.bytes_processed:,}")
    
    except (OSError, ValueError) as e:
        sys.exit(f"\nERROR: {e}")
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        sys.exit(f"\nERROR: {e}")
    
    finally:
        # Clean up resources
        print("\nCleaning up...")
        
        if sock:
            sock.close()
            print("  ✓ Socket closed")
        
        if tc_hook:
            tc_hook.detach()
            print("  ✓ TC hook detached")
        
        if bpf_obj and libbpf:
            libbpf.close(bpf_obj)
            print("  ✓ BPF object closed")
    
    print("\n" + "=" * 60)
    print("Goodbye!")
    print("=" * 60)


if __name__ == "__main__":
    main()