#!/usr/bin/env python3
"""
eBPF Hook Monitor

Displays per-flow packet statistics gathered by eBPF programs.

This tool supports two attachment modes:
    - socket: loads the socket filter program via libbpf and attaches it to a raw
        packet socket (SO_ATTACH_BPF).
    - tc: loads and pins the TC classifier program + maps via bpftool, then
        attaches the pinned program to clsact ingress/egress with tc.

Usage:
        sudo python3 python-controller --hook socket --interface ens33
        sudo python3 python-controller --hook tc --interface ens33

Requirements:
    - libbpf: sudo apt-get install libbpf-dev
        - bpftool (for tc mode): sudo apt-get install linux-tools-generic
        - tc (iproute2, for tc mode): sudo apt-get install iproute2
    - Root privileges (sudo)
    - Compiled eBPF programs: make
"""

import argparse
import ctypes
import ctypes.util
import os
import signal
import socket
import struct
import subprocess
import sys
import time


# ============================================================================
# Constants
# ============================================================================

SO_ATTACH_BPF = 50       # Socket option to attach eBPF program
ETH_P_ALL = 0x0003       # Capture all Ethernet protocols
BPF_MAP_LOOKUP_ELEM = 1  # BPF syscall command: lookup map element
BPF_MAP_GET_NEXT_KEY = 4 # BPF syscall command: iterate map keys
BPF_OBJ_GET = 7          # BPF syscall command: open a pinned BPF object
__NR_bpf = 321           # BPF syscall number on x86_64 Linux

# Hook types
HOOK_SOCKET = "socket"
HOOK_TC = "tc"


# ============================================================================
# Data Structures
#
# These must exactly match the C structs in common.h, including padding.
# ============================================================================

class FlowKey(ctypes.Structure):
    """
    5-tuple flow identifier.
    
    Matches struct flow_key in common.h (16 bytes total).
    Used as the key in the BPF hash map.
    """
    _fields_ = [
        ("src_ip", ctypes.c_uint32),     # Source IP (network byte order)
        ("dst_ip", ctypes.c_uint32),     # Destination IP (network byte order)
        ("src_port", ctypes.c_uint16),   # Source port (network byte order)
        ("dst_port", ctypes.c_uint16),   # Destination port (network byte order)
        ("proto", ctypes.c_uint8),       # Protocol (1=ICMP, 6=TCP, 17=UDP)
        ("_pad", ctypes.c_uint8 * 3),    # Padding for alignment
    ]


class PacketMetrics(ctypes.Structure):
    """
    Per-flow packet statistics.
    
    Matches struct packet_metrics in common.h (32 bytes total).
    Used as the value in the BPF hash map.
    """
    _fields_ = [
        ("packets_processed", ctypes.c_uint32),  # Packet count
        ("_pad", ctypes.c_uint32),               # Padding (C compiler inserts this)
        ("bytes_processed", ctypes.c_uint64),    # Total bytes
        ("total_latency_ns", ctypes.c_uint64),   # Reserved for latency tracking
        ("timestamp", ctypes.c_uint64),          # Last seen (nanoseconds)
    ]


# ============================================================================
# libbpf Wrapper
#
# Provides Python access to libbpf functions for loading eBPF programs.
# ============================================================================

class LibBPF:
    """
    Minimal wrapper around the libbpf shared library.
    
    Uses ctypes to call libbpf functions for:
    - Opening compiled eBPF object files (.o)
    - Loading programs into the kernel
    - Getting file descriptors for programs and maps
    """
    
    def __init__(self):
        """Find and load the libbpf shared library."""
        # Try standard library lookup first
        lib_path = ctypes.util.find_library("bpf")
        
        # Fall back to common installation paths
        if not lib_path:
            for path in ["/usr/lib/x86_64-linux-gnu/libbpf.so.1",
                         "/usr/lib/x86_64-linux-gnu/libbpf.so.0",
                         "/usr/lib/libbpf.so.1",
                         "/usr/lib/libbpf.so"]:
                if os.path.exists(path):
                    lib_path = path
                    break
        
        if not lib_path:
            raise OSError("libbpf not found. Install: sudo apt-get install libbpf-dev")
        
        self.lib = ctypes.CDLL(lib_path, use_errno=True)
        self._setup_function_signatures()
    
    def _setup_function_signatures(self):
        """Define C function argument/return types for type safety."""
        L = self.lib
        
        # Opening and loading BPF objects
        L.bpf_object__open.argtypes = [ctypes.c_char_p]
        L.bpf_object__open.restype = ctypes.c_void_p
        
        L.bpf_object__load.argtypes = [ctypes.c_void_p]
        L.bpf_object__load.restype = ctypes.c_int
        
        L.bpf_object__close.argtypes = [ctypes.c_void_p]
        L.bpf_object__close.restype = None
        
        # Finding programs by name
        L.bpf_object__find_program_by_name.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        L.bpf_object__find_program_by_name.restype = ctypes.c_void_p
        
        L.bpf_program__fd.argtypes = [ctypes.c_void_p]
        L.bpf_program__fd.restype = ctypes.c_int
        
        # Finding maps by name
        L.bpf_object__find_map_by_name.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        L.bpf_object__find_map_by_name.restype = ctypes.c_void_p
        
        L.bpf_map__fd.argtypes = [ctypes.c_void_p]
        L.bpf_map__fd.restype = ctypes.c_int
    
    def open_and_load(self, path):
        """
        Open a compiled BPF object file and load it into the kernel.
        
        Returns the BPF object handle (needed for cleanup).
        """
        obj = self.lib.bpf_object__open(path.encode())
        if not obj:
            raise OSError(f"Failed to open: {path}")
        
        if self.lib.bpf_object__load(obj) != 0:
            self.lib.bpf_object__close(obj)
            raise OSError(f"Failed to load: {path}")
        
        return obj
    
    def close(self, obj):
        """Close a BPF object and free resources."""
        if obj:
            self.lib.bpf_object__close(obj)
    
    def get_program_fd(self, obj, name):
        """Get the file descriptor for a BPF program by name."""
        prog = self.lib.bpf_object__find_program_by_name(obj, name.encode())
        if not prog:
            raise ValueError(f"Program not found: {name}")
        
        fd = self.lib.bpf_program__fd(prog)
        if fd < 0:
            raise ValueError(f"Invalid program fd: {name}")
        return fd
    
    def get_map_fd(self, obj, name):
        """Get the file descriptor for a BPF map by name."""
        m = self.lib.bpf_object__find_map_by_name(obj, name.encode())
        if not m:
            raise ValueError(f"Map not found: {name}")
        
        fd = self.lib.bpf_map__fd(m)
        if fd < 0:
            raise ValueError(f"Invalid map fd: {name}")
        return fd


# ============================================================================
# BPF Map Operations
#
# Uses the bpf() syscall directly to read entries from BPF maps.
# ============================================================================

# Cache libc to avoid reloading on each syscall
_libc = ctypes.CDLL(None, use_errno=True)


class _BpfMapAttr(ctypes.Structure):
    """
    Attribute structure for BPF map syscalls.
    
    This matches the kernel's bpf_attr union for map operations.
    See: linux/bpf.h
    """
    _fields_ = [
        ("map_fd", ctypes.c_uint32),    # File descriptor of the map
        ("_pad", ctypes.c_uint32),      # Padding for alignment
        # NOTE: The kernel requires different minimum attr sizes per command.
        # In particular, BPF_MAP_LOOKUP_ELEM requires the 'flags' field.
        # Keeping a single 32-byte layout works for both LOOKUP and GET_NEXT_KEY.
        ("key_ptr", ctypes.c_uint64),   # Pointer to key buffer (or 0 for first key)
        ("val_ptr", ctypes.c_uint64),   # Pointer to value buffer (lookup) or next_key (iterate)
        ("flags", ctypes.c_uint64),     # BPF_MAP_LOOKUP_ELEM flags (usually 0)
    ]


def _bpf_map_syscall(cmd, map_fd, key_ptr, val_ptr):
    """
    Execute a BPF map syscall.
    
    Args:
        cmd: BPF_MAP_LOOKUP_ELEM or BPF_MAP_GET_NEXT_KEY
        map_fd: Map file descriptor
        key_ptr: Address of key buffer (or 0 for first key)
        val_ptr: Address of value buffer (lookup) or next_key buffer (iterate)
    
    Returns:
        True on success, False on error (e.g., key not found, no more keys)
    """
    attr = _BpfMapAttr(
        map_fd=map_fd,
        key_ptr=key_ptr,
        val_ptr=val_ptr,
        flags=0,
    )
    ret = _libc.syscall(__NR_bpf, cmd, ctypes.byref(attr), ctypes.sizeof(attr))
    return ret >= 0


class _BpfObjAttr(ctypes.Structure):
    """bpf_attr layout for BPF_OBJ_GET (and BPF_OBJ_PIN)."""
    _fields_ = [
        ("pathname", ctypes.c_uint64),
        ("bpf_fd", ctypes.c_uint32),
        ("file_flags", ctypes.c_uint32),
        ("path_fd", ctypes.c_int32),
    ]


def bpf_obj_get(path):
    """Open a pinned BPF object from bpffs and return a new fd."""
    path_bytes = os.fsencode(path) + b"\0"
    buf = ctypes.create_string_buffer(path_bytes)
    attr = _BpfObjAttr(
        pathname=ctypes.addressof(buf),
        bpf_fd=0,
        file_flags=0,
        path_fd=0,
    )
    fd = _libc.syscall(__NR_bpf, BPF_OBJ_GET, ctypes.byref(attr), ctypes.sizeof(attr))
    if fd < 0:
        err = ctypes.get_errno()
        raise OSError(err, f"BPF_OBJ_GET failed for {path}")
    return int(fd)


def iterate_map(map_fd):
    """
    Read all entries from a BPF hash map.
    
    Uses BPF_MAP_GET_NEXT_KEY to iterate through keys,
    and BPF_MAP_LOOKUP_ELEM to get the value for each key.
    
    Returns:
        List of (FlowKey, PacketMetrics) tuples
    """
    entries = []
    
    # Working buffers (reused during iteration)
    key = FlowKey()
    next_key = FlowKey()
    value = PacketMetrics()
    
    # Get the first key by passing NULL (0) as the current key
    if not _bpf_map_syscall(BPF_MAP_GET_NEXT_KEY, map_fd, 0, ctypes.addressof(next_key)):
        return entries  # Map is empty
    
    while True:
        # Move next_key to key for the lookup
        ctypes.pointer(key)[0] = next_key
        
        # Look up the value for this key
        if _bpf_map_syscall(BPF_MAP_LOOKUP_ELEM, map_fd,
                           ctypes.addressof(key), ctypes.addressof(value)):
            # Create copies to store (the buffers get overwritten)
            entries.append((
                FlowKey.from_buffer_copy(bytes(key)),
                PacketMetrics.from_buffer_copy(bytes(value))
            ))
        
        # Get the next key (using current key as reference)
        if not _bpf_map_syscall(BPF_MAP_GET_NEXT_KEY, map_fd,
                               ctypes.addressof(key), ctypes.addressof(next_key)):
            break  # No more keys
    
    return entries


# ============================================================================
# TC Hook Management
#
# Uses the 'tc' command to attach/detach TC eBPF programs.
# ============================================================================

class TCHook:
    """
    Manages TC (Traffic Control) hook attachment/detachment.
    
    TC hooks are attached using the 'tc' command-line tool, which sets up
    the qdisc (queueing discipline) and filters for eBPF program attachment.
    """
    
    def __init__(self, interface, bpf_file):
        self.interface = interface
        self.bpf_file = bpf_file
        self.attached = False
        self.metrics_fd = None
        self.debug_fd = None
        self.pin_root = f"/sys/fs/bpf/popplumb-tc-{interface}-{os.getpid()}"
        self.pin_maps = os.path.join(self.pin_root, "maps")
        self.pin_prog = None
    
    def _run_tc(self, args, check=True):
        """Run a tc command and return success status."""
        cmd = ["tc"] + args
        try:
            result = subprocess.run(cmd, capture_output=True, text=True)
            if check and result.returncode != 0:
                # Ignore "file exists" errors when adding qdisc (already exists)
                if "File exists" not in result.stderr:
                    return False, result.stderr.strip()
            return True, result.stdout.strip()
        except FileNotFoundError:
            return False, "tc command not found. Install: sudo apt-get install iproute2"
    
    def attach(self):
        """
        Attach TC eBPF program to the interface.
        
        IMPORTANT (root cause of "TC shows zeros"):
        If you attach with `tc ... bpf obj <file>`, tc loads its *own* instance
        of the BPF object (and creates its own maps). If Python also loads the
        object separately, Python will read a different map instance.

        This implementation pins the program + maps into bpffs using bpftool,
        then attaches the pinned program with tc. Python opens the pinned maps
        via BPF_OBJ_GET, guaranteeing it reads the same maps the tc hook uses.

        Steps:
        1. Add clsact qdisc
        2. bpftool load+pin program and maps
        3. Attach pinned program to ingress + egress
        4. Open pinned map fds for userspace monitoring
        """
        # Step 1: Add clsact qdisc (may already exist).
        success, err = self._run_tc(["qdisc", "add", "dev", self.interface, "clsact"], check=True)
        if not success:
            raise OSError(f"Failed to add clsact qdisc: {err}")
        
        # Ensure bpffs exists (most distros mount it at boot, but be defensive).
        os.makedirs("/sys/fs/bpf", exist_ok=True)
        subprocess.run(["mount", "-t", "bpf", "bpf", "/sys/fs/bpf"],
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        # Create pin directories.
        os.makedirs(self.pin_maps, exist_ok=True)

        # Load and pin program(s) + maps. The tc program is a SCHED_CLS (classifier).
        # `pinmaps` makes all maps available at predictable paths.
        cmd = [
            "bpftool", "prog", "loadall",
            self.bpf_file, self.pin_root,
            "type", "classifier",
            "pinmaps", self.pin_maps,
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            raise OSError(f"bpftool loadall failed: {result.stderr.strip() or result.stdout.strip()}")

        # Discover the pinned program path. loadall pins programs directly under pin_root.
        prog_candidates = []
        for entry in os.listdir(self.pin_root):
            full = os.path.join(self.pin_root, entry)
            if entry == "maps":
                continue
            if os.path.isdir(full):
                continue
            prog_candidates.append(full)

        if not prog_candidates:
            raise OSError("bpftool loadall did not pin any program")

        # Prefer the function name if present; otherwise take the only entry.
        prog_candidates.sort()
        for p in prog_candidates:
            if os.path.basename(p) in ("tc_packet_filter", "tc"):
                self.pin_prog = p
                break
        if self.pin_prog is None:
            self.pin_prog = prog_candidates[0]

        # Attach pinned program to ingress+egress. Use 'replace' to be repeatable.
        for direction in ("ingress", "egress"):
            success, err = self._run_tc([
                "filter", "replace", "dev", self.interface,
                direction, "bpf", "direct-action",
                "object-pinned", self.pin_prog,
            ])
            if not success:
                raise OSError(f"Failed to attach TC {direction} filter: {err}")

        # Open pinned maps for monitoring.
        metrics_path = os.path.join(self.pin_maps, "tc_metrics")
        debug_path = os.path.join(self.pin_maps, "tc_debug")
        self.metrics_fd = bpf_obj_get(metrics_path)
        self.debug_fd = bpf_obj_get(debug_path) if os.path.exists(debug_path) else None

        self.attached = True
    
    def detach(self):
        """
        Detach TC eBPF program from the interface.
        
        Removes the clsact qdisc, which also removes all attached filters.
        """
        if not self.attached:
            return
        
        # Remove the clsact qdisc (this removes all filters too)
        self._run_tc(["qdisc", "del", "dev", self.interface, "clsact"], check=False)
        # Close any imported map fds.
        for fd in (self.metrics_fd, self.debug_fd):
            if fd is None:
                continue
            try:
                os.close(fd)
            except OSError:
                pass
        self.metrics_fd = None
        self.debug_fd = None

        # Best-effort cleanup of pinned objects.
        try:
            if os.path.isdir(self.pin_maps):
                for name in os.listdir(self.pin_maps):
                    try:
                        os.unlink(os.path.join(self.pin_maps, name))
                    except OSError:
                        pass
                try:
                    os.rmdir(self.pin_maps)
                except OSError:
                    pass

            if os.path.isdir(self.pin_root):
                for name in os.listdir(self.pin_root):
                    full = os.path.join(self.pin_root, name)
                    if os.path.isdir(full):
                        continue
                    try:
                        os.unlink(full)
                    except OSError:
                        pass
                try:
                    os.rmdir(self.pin_root)
                except OSError:
                    pass
        except OSError:
            pass

        self.attached = False


# ============================================================================
# Display Helpers
# ============================================================================

def format_ip(ip_int):
    """Convert 32-bit integer to dotted decimal (e.g., "127.0.0.1")."""
    # Stored in the BPF map in network byte order.
    # `ctypes` exposes it as a host-endian integer, so normalize first.
    return socket.inet_ntoa(struct.pack("!I", socket.ntohl(ip_int)))


def format_port(port_int):
    """Convert port from network byte order to host byte order."""
    return socket.ntohs(port_int)


def get_interfaces():
    """Get list of available network interfaces."""
    try:
        return sorted(os.listdir("/sys/class/net"))
    except OSError:
        return []


# ============================================================================
# Main Program
# ============================================================================

# Global flag for clean shutdown
keep_running = True


def signal_handler(sig, frame):
    """Handle Ctrl+C for graceful shutdown."""
    global keep_running
    print("\n\nStopping...")
    keep_running = False


def main():
    global keep_running
    
    # -------------------------------------------------------------------------
    # Parse command-line arguments
    # -------------------------------------------------------------------------
    parser = argparse.ArgumentParser(description="eBPF Hook Monitor")
    parser.add_argument("--hook", required=True, choices=[HOOK_SOCKET, HOOK_TC],
                        help="Which hook to use: 'socket' or 'tc'")
    parser.add_argument("--interface", default="lo",
                        help="Network interface to monitor (default: lo)")
    parser.add_argument("-i", "--interval", type=int, default=5,
                        help="Update interval in seconds (default: 5)")
    parser.add_argument("--top", type=int, default=10,
                        help="Number of top flows to show (default: 10)")
    parser.add_argument("--debug", action="store_true",
                        help="Print TC debug counters each interval (tc mode only)")
    args = parser.parse_args()
    
    # -------------------------------------------------------------------------
    # Validate prerequisites
    # -------------------------------------------------------------------------
    if os.geteuid() != 0:
        sys.exit("ERROR: Run as root (sudo)")
    
    interfaces = get_interfaces()
    if args.interface not in interfaces:
        sys.exit(f"ERROR: Interface '{args.interface}' not found. "
                 f"Available: {', '.join(interfaces)}")
    
    hook_type = args.hook
    
    # Determine BPF file and program/map names based on hook type
    if hook_type == HOOK_SOCKET:
        bpf_file = ".output/socket_hook.o"
        prog_name = "socket_packet_filter"
        map_name = "socket_metrics"
        hook_display = "Socket Layer"
    else:  # HOOK_TC
        bpf_file = ".output/tc_hook.o"
        hook_display = "TC (Traffic Control)"
    
    # Verify BPF file exists
    if not os.path.exists(bpf_file):
        sys.exit(f"ERROR: {bpf_file} not found. Run 'make' first.")
    
    # -------------------------------------------------------------------------
    # Display configuration
    # -------------------------------------------------------------------------
    print()
    print("=" * 60)
    print(f"{hook_display} Hook Monitor")
    print("=" * 60)
    print(f"Hook Type: {hook_display}")
    print(f"BPF File:  {bpf_file}")
    print(f"Interface: {args.interface}")
    print(f"Interval:  {args.interval}s")
    print()
    
    # Set up signal handlers for clean shutdown
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # -------------------------------------------------------------------------
    # Load/attach BPF program
    # -------------------------------------------------------------------------

    # Initialize to None for cleanup in finally block
    bpf_obj = None
    sock = None
    tc_hook = None
    libbpf = None
    map_fd = None
    debug_fd = None
    
    try:
        # Attach based on hook type
        if hook_type == HOOK_SOCKET:
            # Load the compiled eBPF program
            print("Loading eBPF program...")
            libbpf = LibBPF()
            bpf_obj = libbpf.open_and_load(bpf_file)
            print("  ✓ Loaded into kernel")

            # Get file descriptors for the program and map
            prog_fd = libbpf.get_program_fd(bpf_obj, prog_name)
            map_fd = libbpf.get_map_fd(bpf_obj, map_name)
            print(f"  ✓ Program fd={prog_fd}, Map fd={map_fd}")

            # Create a raw packet socket and attach BPF filter
            sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))
            sock.setsockopt(socket.SOL_SOCKET, SO_ATTACH_BPF, struct.pack("I", prog_fd))
            sock.bind((args.interface, 0))
            print(f"  ✓ Attached to socket on {args.interface}")
        
        else:  # HOOK_TC
            # Attach via tc using a pinned program/maps, and read pinned maps.
            print("Attaching TC filters (bpftool pin + tc object-pinned)...")
            tc_hook = TCHook(args.interface, bpf_file)
            tc_hook.attach()
            print(f"  ✓ Attached TC hook on {args.interface}")

            map_fd = tc_hook.metrics_fd
            debug_fd = tc_hook.debug_fd
        
        # ---------------------------------------------------------------------
        # Monitoring loop
        # ---------------------------------------------------------------------
        print("\n" + "=" * 60)
        print("Monitoring... Press Ctrl+C to stop")
        print("=" * 60)
        
        proto_names = {1: "ICMP", 6: "TCP", 17: "UDP"}
        
        while keep_running:
            time.sleep(args.interval)
            if not keep_running:
                break
            
            # Optional debug counters for TC hook
            if hook_type == HOOK_TC and args.debug and debug_fd is not None:
                print("\n" + "=" * 60)
                print("DEBUG COUNTERS (from BPF program):")
                # Keep in sync with the enum in src/ebpf/tc_hook.c
                debug_names = [
                    "Total packets",
                    "Not IPv4",
                    "IPv4 packets",
                    "Parsed packets",
                    "Map updates",
                    "Map insert race",
                    "Bounds errors",
                    "Header/frag errors",
                ]
                for i in range(len(debug_names)):
                    key = ctypes.c_uint32(i)
                    value = ctypes.c_uint64(0)
                    if _bpf_map_syscall(BPF_MAP_LOOKUP_ELEM, debug_fd,
                                       ctypes.addressof(key), ctypes.addressof(value)):
                        print(f"  {debug_names[i]}: {value.value}")
                    else:
                        print(f"  {debug_names[i]}: <read failed>")
                print("=" * 60)
            
            # Read all flows from the BPF map
            flows = iterate_map(map_fd)
            
            # Display flow statistics
            print("\n" + "-" * 60)
            print(f"[{hook_display}] Active flows: {len(flows)}")
            print("-" * 60)
            
            if not flows:
                print("No traffic captured yet. Try: ping 127.0.0.1")
                continue
            
            # Sort by packet count (highest first)
            flows.sort(key=lambda x: x[1].packets_processed, reverse=True)
            
            # Show top N flows
            for i, (key, val) in enumerate(flows[:max(0, args.top)], 1):
                proto = proto_names.get(key.proto, f"Proto-{key.proto}")
                src = f"{format_ip(key.src_ip)}:{format_port(key.src_port)}"
                dst = f"{format_ip(key.dst_ip)}:{format_port(key.dst_port)}"
                print(f"{i:2}. {src} → {dst} ({proto})")
                print(f"    Packets: {val.packets_processed:,}  "
                      f"Bytes: {val.bytes_processed:,}")
    
    except (OSError, ValueError) as e:
        sys.exit(f"\nERROR: {e}")
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        sys.exit(f"\nERROR: {e}")
    
    finally:
        # Clean up resources
        print("\nCleaning up...")
        
        if sock:
            sock.close()
            print("  ✓ Socket closed")
        
        if tc_hook:
            tc_hook.detach()
            print("  ✓ TC hook detached")
        
        if bpf_obj and libbpf:
            libbpf.close(bpf_obj)
            print("  ✓ BPF object closed")
    
    print("\n" + "=" * 60)
    print("Goodbye!")
    print("=" * 60)


if __name__ == "__main__":
    main()