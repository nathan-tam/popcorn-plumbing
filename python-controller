#!/usr/bin/env python3
"""
Socket Hook Monitor

Loads a pre-compiled eBPF socket filter using libbpf and displays packet statistics.

Usage:
    sudo python3 python-controller --interface lo

Requirements:
    - libbpf: sudo apt-get install libbpf-dev
    - Root privileges (sudo)
    - Compiled eBPF program: make
"""

import argparse
import ctypes
import ctypes.util
import os
import signal
import socket
import struct
import sys
import time


# ============================================================================
# Constants
# ============================================================================

SO_ATTACH_BPF = 50       # Socket option to attach BPF program
ETH_P_ALL = 0x0003       # Capture all ethernet protocols
BPF_MAP_LOOKUP_ELEM = 1  # BPF syscall: lookup map element
BPF_MAP_GET_NEXT_KEY = 4 # BPF syscall: get next map key
__NR_bpf = 321           # BPF syscall number (x86_64)


# ============================================================================
# Data Structures (must match common.h)
# ============================================================================

class FlowKey(ctypes.Structure):
    """
    5-tuple flow identifier - matches struct flow_key in common.h
    
    Total size: 16 bytes
    """
    _fields_ = [
        ("src_ip", ctypes.c_uint32),     # Source IPv4 address
        ("dst_ip", ctypes.c_uint32),     # Destination IPv4 address
        ("src_port", ctypes.c_uint16),   # Source port
        ("dst_port", ctypes.c_uint16),   # Destination port
        ("proto", ctypes.c_uint8),       # Protocol (TCP=6, UDP=17, ICMP=1)
        ("_pad", ctypes.c_uint8 * 3),    # Padding for alignment
    ]


class PacketMetrics(ctypes.Structure):
    """
    Per-flow statistics - matches struct packet_metrics in common.h
    
    Note: 4 bytes of padding after packets_processed for 8-byte alignment.
    Total size: 32 bytes
    """
    _fields_ = [
        ("packets_processed", ctypes.c_uint32),
        ("_pad", ctypes.c_uint32),        # Implicit padding in C struct
        ("bytes_processed", ctypes.c_uint64),
        ("total_latency_ns", ctypes.c_uint64),
        ("timestamp", ctypes.c_uint64),
    ]


# ============================================================================
# libbpf Wrapper
# ============================================================================

class LibBPF:
    """Minimal wrapper around libbpf shared library."""
    
    def __init__(self):
        """Load libbpf and set up function signatures."""
        # Find the libbpf shared library
        lib_path = ctypes.util.find_library("bpf")
        if not lib_path:
            # Try common paths if find_library fails
            for path in ["/usr/lib/x86_64-linux-gnu/libbpf.so.1",
                         "/usr/lib/x86_64-linux-gnu/libbpf.so.0",
                         "/usr/lib/libbpf.so.1",
                         "/usr/lib/libbpf.so"]:
                if os.path.exists(path):
                    lib_path = path
                    break
        
        if not lib_path:
            raise OSError("libbpf not found. Install: sudo apt-get install libbpf-dev")
        
        self.lib = ctypes.CDLL(lib_path, use_errno=True)
        self._define_functions()
    
    def _define_functions(self):
        """Define C function signatures for type safety."""
        # bpf_object *bpf_object__open(const char *path)
        self.lib.bpf_object__open.argtypes = [ctypes.c_char_p]
        self.lib.bpf_object__open.restype = ctypes.c_void_p
        
        # int bpf_object__load(struct bpf_object *obj)
        self.lib.bpf_object__load.argtypes = [ctypes.c_void_p]
        self.lib.bpf_object__load.restype = ctypes.c_int
        
        # void bpf_object__close(struct bpf_object *obj)
        self.lib.bpf_object__close.argtypes = [ctypes.c_void_p]
        self.lib.bpf_object__close.restype = None
        
        # struct bpf_program *bpf_object__find_program_by_name(obj, name)
        self.lib.bpf_object__find_program_by_name.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        self.lib.bpf_object__find_program_by_name.restype = ctypes.c_void_p
        
        # int bpf_program__fd(const struct bpf_program *prog)
        self.lib.bpf_program__fd.argtypes = [ctypes.c_void_p]
        self.lib.bpf_program__fd.restype = ctypes.c_int
        
        # struct bpf_map *bpf_object__find_map_by_name(obj, name)
        self.lib.bpf_object__find_map_by_name.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        self.lib.bpf_object__find_map_by_name.restype = ctypes.c_void_p
        
        # int bpf_map__fd(const struct bpf_map *map)
        self.lib.bpf_map__fd.argtypes = [ctypes.c_void_p]
        self.lib.bpf_map__fd.restype = ctypes.c_int
    
    def open_and_load(self, path):
        """Open a BPF object file and load it into the kernel."""
        obj = self.lib.bpf_object__open(path.encode())
        if not obj:
            raise OSError(f"Failed to open BPF object: {path}")
        
        ret = self.lib.bpf_object__load(obj)
        if ret != 0:
            self.lib.bpf_object__close(obj)
            raise OSError(f"Failed to load BPF object (error {ret})")
        
        return obj
    
    def close(self, obj):
        """Close a BPF object."""
        if obj:
            self.lib.bpf_object__close(obj)
    
    def get_program_fd(self, obj, name):
        """Get file descriptor for a BPF program by name."""
        prog = self.lib.bpf_object__find_program_by_name(obj, name.encode())
        if not prog:
            raise ValueError(f"Program '{name}' not found")
        
        fd = self.lib.bpf_program__fd(prog)
        if fd < 0:
            raise ValueError(f"Program '{name}' has invalid fd")
        return fd
    
    def get_map_fd(self, obj, name):
        """Get file descriptor for a BPF map by name."""
        bpf_map = self.lib.bpf_object__find_map_by_name(obj, name.encode())
        if not bpf_map:
            raise ValueError(f"Map '{name}' not found")
        
        fd = self.lib.bpf_map__fd(bpf_map)
        if fd < 0:
            raise ValueError(f"Map '{name}' has invalid fd")
        return fd


# ============================================================================
# BPF Map Operations
# ============================================================================

# Load libc once for syscalls
_libc = ctypes.CDLL(None, use_errno=True)


class _BpfMapAttr(ctypes.Structure):
    """Attribute structure for BPF map syscalls."""
    _fields_ = [
        ("map_fd", ctypes.c_uint32),
        ("_pad0", ctypes.c_uint32),
        ("key", ctypes.c_uint64),
        ("value_or_next", ctypes.c_uint64),  # value for lookup, next_key for get_next
    ]


def _bpf_map_lookup(map_fd, key_buf, value_buf):
    """Look up an element in a BPF map. Returns True if found."""
    attr = _BpfMapAttr()
    attr.map_fd = map_fd
    attr.key = ctypes.addressof(key_buf)
    attr.value_or_next = ctypes.addressof(value_buf)
    
    return _libc.syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, 
                         ctypes.byref(attr), ctypes.sizeof(attr)) >= 0


def _bpf_map_get_next_key(map_fd, key_buf, next_key_buf, is_first):
    """Get the next key in a BPF map. Returns True if found."""
    attr = _BpfMapAttr()
    attr.map_fd = map_fd
    attr.key = 0 if is_first else ctypes.addressof(key_buf)
    attr.value_or_next = ctypes.addressof(next_key_buf)
    
    return _libc.syscall(__NR_bpf, BPF_MAP_GET_NEXT_KEY,
                         ctypes.byref(attr), ctypes.sizeof(attr)) >= 0


def iterate_map(map_fd):
    """
    Iterate over all entries in a BPF hash map.
    
    Returns list of (FlowKey, PacketMetrics) tuples.
    """
    entries = []
    
    # Buffers for keys and values
    key = FlowKey()
    next_key = FlowKey()
    value = PacketMetrics()
    
    # Get first key
    if not _bpf_map_get_next_key(map_fd, key, next_key, is_first=True):
        return entries  # Map is empty
    
    while True:
        # Copy next_key to key for lookup
        ctypes.memmove(ctypes.addressof(key), ctypes.addressof(next_key), 
                       ctypes.sizeof(FlowKey))
        
        # Look up the value
        if _bpf_map_lookup(map_fd, key, value):
            # Make copies of the data
            key_copy = FlowKey()
            value_copy = PacketMetrics()
            ctypes.memmove(ctypes.addressof(key_copy), ctypes.addressof(key),
                           ctypes.sizeof(FlowKey))
            ctypes.memmove(ctypes.addressof(value_copy), ctypes.addressof(value),
                           ctypes.sizeof(PacketMetrics))
            entries.append((key_copy, value_copy))
        
        # Get next key
        if not _bpf_map_get_next_key(map_fd, key, next_key, is_first=False):
            break  # No more keys
    
    return entries


# ============================================================================
# Helper Functions
# ============================================================================

def format_ip(ip_int):
    """Convert 32-bit integer to dotted decimal (e.g., "192.168.1.1")."""
    return socket.inet_ntoa(struct.pack("I", ip_int))


def format_port(port_int):
    """Convert port from network byte order to host byte order."""
    return socket.ntohs(port_int)


def get_interfaces():
    """List available network interfaces."""
    net_dir = "/sys/class/net"
    if os.path.exists(net_dir):
        return sorted(os.listdir(net_dir))
    return []


# ============================================================================
# Main Program
# ============================================================================

keep_running = True  # Global flag for signal handler


def signal_handler(sig, frame):
    """Handle Ctrl+C for graceful shutdown."""
    global keep_running
    print("\n\nStopping...")
    keep_running = False


def main():
    global keep_running
    
    # -------------------------------------------------------------------------
    # Parse arguments
    # -------------------------------------------------------------------------
    parser = argparse.ArgumentParser(description="eBPF Socket Hook Monitor")
    parser.add_argument("--bpf-file", default=".output/socket_hook.o",
                        help="Path to compiled eBPF object")
    parser.add_argument("--interface", default="lo",
                        help="Network interface to monitor")
    parser.add_argument("-i", "--interval", type=int, default=5,
                        help="Update interval in seconds")
    args = parser.parse_args()
    
    # -------------------------------------------------------------------------
    # Validate prerequisites
    # -------------------------------------------------------------------------
    if os.geteuid() != 0:
        print("ERROR: Run as root (sudo)")
        sys.exit(1)
    
    if not os.path.exists(args.bpf_file):
        print(f"ERROR: {args.bpf_file} not found. Run 'make' first.")
        sys.exit(1)
    
    interfaces = get_interfaces()
    if args.interface not in interfaces:
        print(f"ERROR: Interface '{args.interface}' not found")
        print(f"Available: {', '.join(interfaces)}")
        sys.exit(1)
    
    # -------------------------------------------------------------------------
    # Display configuration
    # -------------------------------------------------------------------------
    print("=" * 60)
    print("Socket Hook Monitor")
    print("=" * 60)
    print(f"BPF File:  {args.bpf_file}")
    print(f"Interface: {args.interface}")
    print(f"Interval:  {args.interval}s")
    print()
    
    # Set up signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # -------------------------------------------------------------------------
    # Load BPF program and attach to socket
    # -------------------------------------------------------------------------
    bpf_obj = None
    sock = None
    
    try:
        print("Loading eBPF program...")
        libbpf = LibBPF()
        
        # Open and load the BPF object
        bpf_obj = libbpf.open_and_load(args.bpf_file)
        print("  ✓ Loaded into kernel")
        
        # Get program and map file descriptors
        prog_fd = libbpf.get_program_fd(bpf_obj, "socket_packet_filter")
        map_fd = libbpf.get_map_fd(bpf_obj, "socket_metrics")
        print(f"  ✓ Program fd={prog_fd}, Map fd={map_fd}")
        
        # Create raw socket and attach BPF filter
        sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))
        sock.setsockopt(socket.SOL_SOCKET, SO_ATTACH_BPF, struct.pack("I", prog_fd))
        sock.bind((args.interface, 0))
        print(f"  ✓ Attached to {args.interface}")
        
        # ---------------------------------------------------------------------
        # Monitoring loop
        # ---------------------------------------------------------------------
        print("\n" + "=" * 60)
        print("Monitoring... Press Ctrl+C to stop")
        print("=" * 60)
        
        proto_names = {1: "ICMP", 6: "TCP", 17: "UDP"}
        
        while keep_running:
            time.sleep(args.interval)
            if not keep_running:
                break
            
            # Read flows from BPF map
            flows = iterate_map(map_fd)
            
            print("\n" + "-" * 60)
            print(f"Active flows: {len(flows)}")
            print("-" * 60)
            
            if not flows:
                print("No traffic captured yet. Try: ping 127.0.0.1")
                continue
            
            # Sort by packet count (descending)
            flows.sort(key=lambda x: x[1].packets_processed, reverse=True)
            
            # Display top 10 flows
            for i, (key, val) in enumerate(flows[:10], 1):
                proto = proto_names.get(key.proto, f"Proto-{key.proto}")
                src = f"{format_ip(key.src_ip)}:{format_port(key.src_port)}"
                dst = f"{format_ip(key.dst_ip)}:{format_port(key.dst_port)}"
                print(f"{i:2}. {src} → {dst} ({proto})")
                print(f"    Packets: {val.packets_processed:,}  Bytes: {val.bytes_processed:,}")
    
    except OSError as e:
        print(f"\nERROR: {e}")
        sys.exit(1)
    
    except Exception as e:
        print(f"\nERROR: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
    
    finally:
        # Cleanup
        if sock:
            sock.close()
        if bpf_obj:
            libbpf.close(bpf_obj)
    
    print("\n" + "=" * 60)
    print("Goodbye!")
    print("=" * 60)


if __name__ == "__main__":
    main()